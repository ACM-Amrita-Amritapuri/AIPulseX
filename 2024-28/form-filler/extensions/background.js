const API_BASE_URL = "http://localhost:8000";
let latestSchema = null;

// Helper: ask the content script for schema, await the next SCHEMA_UPDATE
function fetchSchema(tabId) {
  return new Promise((resolve, reject) => {
    if (latestSchema && latestSchema.length > 0) {
      console.log("üóÇÔ∏è Using cached schema");
      return resolve(latestSchema);
    }

    console.log("üïµÔ∏è Requesting schema from content script...");

    function onSchemaMsg(message, sender) {
      if (message.type === "SCHEMA_UPDATE" && sender.tab.id === tabId) {
        console.log("üì• Received schema from content script:", message.schema);
        latestSchema = message.schema;
        chrome.runtime.onMessage.removeListener(onSchemaMsg);
        resolve(latestSchema);
      }
    }

    chrome.runtime.onMessage.addListener(onSchemaMsg);

    chrome.tabs.sendMessage(tabId, { type: "GET_SCHEMA" }, (response) => {
      if (chrome.runtime.lastError) {
        chrome.runtime.onMessage.removeListener(onSchemaMsg);
        return reject(new Error("Content script not reachable: " + chrome.runtime.lastError.message));
      }
      console.log("üì§ Sent GET_SCHEMA to content script");
    });

    setTimeout(() => {
      chrome.runtime.onMessage.removeListener(onSchemaMsg);
      reject(new Error("Timed out waiting for schema from content script"));
    }, 10000);
  });
}

// Main form‚Äëfill handler
async function handleFormFill(settings, tabId, sendResponse) {
  try {
    console.log("üîÑ [background] Starting form fill process");
    latestSchema = null;

    console.log("üìã [background] Fetching form schema...");
    const schema = await fetchSchema(tabId);

    if (!schema || schema.length === 0) {
      throw new Error("No form schema found. Make sure you're on a Google Forms page.");
    }

    console.log(`üìã [background] Got schema with ${schema.length} fields`);

    const payload = {
      schema_json: JSON.stringify(schema),
      gemini_key: settings.geminiKey,
      groq_key: settings.groqKey,
      pinecone_key: settings.pineconeKey,
      pinecone_env: settings.pineconeEnv,
      pinecone_host: settings.pineconeHost || undefined
    };

    console.log("üì§ [background] Sending to backend...");

    const res = await fetch(`${API_BASE_URL}/fill-form`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Backend returned ${res.status}: ${text}`);
    }

    const result = await res.json();
    console.log("üì• [background] Backend response:", result);

    if (result.status !== "success") {
      throw new Error("Backend reported failure: " + (result.message || "Unknown error"));
    }

    let answers = {};
    try {
      answers = JSON.parse(result.answers_json);
    } catch (parseError) {
      console.warn("‚ö†Ô∏è JSON parse failed, trying regex extraction...");
      const match = result.answers_json.match(/\{[\s\S]*\}/);
      if (match) {
        try {
          answers = JSON.parse(match[0]);
        } catch (regexParseError) {
          throw new Error("Invalid JSON from AI: " + result.answers_json);
        }
      } else {
        throw new Error("No JSON found in AI response: " + result.answers_json);
      }
    }

    console.log("üéØ [background] Parsed answers:", answers);

    if (Object.keys(answers).length === 0) {
      throw new Error("No answers generated by AI. Check if PDF context is relevant to the form.");
    }

    await chrome.tabs.sendMessage(tabId, {
      type: "FILL_ANSWERS",
      answers
    });

    console.log("‚úÖ [background] Form fill completed successfully");

    if (sendResponse) {
      sendResponse({ 
        success: true, 
        message: `Successfully filled form with ${Object.keys(answers).length} answers`,
        answersCount: Object.keys(answers).length
      });
    }

  } catch (err) {
    console.error("‚ùå [background] Form fill failed:", err);

    chrome.tabs.sendMessage(tabId, {
      type: "FILL_ERROR",
      error: err.message
    }).catch(contentError => {
      console.warn("‚ö†Ô∏è [background] Failed to send error to content script:", contentError);
    });

    if (sendResponse) {
      sendResponse({ 
        success: false, 
        error: err.message 
      });
    }
  }
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "SCHEMA_UPDATE") {
    latestSchema = message.schema;
    console.log("üîÑ [background] Schema updated:", latestSchema?.length || 0, "fields");
    sendResponse({ success: true }); // ‚úÖ Fix applied here
    return true; // ‚úÖ Keep channel open until sendResponse is called
  }

  if (message.type === "FILL_FORM") {
    console.log("üîî [background] Got FILL_FORM from popup");
    handleFormFill(message.settings, message.tabId, sendResponse);
    return true;
  }
});

chrome.action.onClicked.addListener(async (tab) => {
  if (tab.url?.includes("docs.google.com/forms") || tab.url?.includes("forms.office.com")) {
    const settings = await chrome.storage.sync.get(
      ["geminiKey", "groqKey", "pineconeKey", "pineconeEnv", "pineconeHost"]
    );
    const hasEnvOrHost = !!settings.pineconeEnv || !!settings.pineconeHost;
    if (settings.geminiKey && settings.groqKey && settings.pineconeKey && hasEnvOrHost) {
      handleFormFill(settings, tab.id);
    } else {
      console.warn("‚ö†Ô∏è API keys missing; open popup to configure them");
      chrome.tabs.sendMessage(tab.id, {
        type: "FILL_ERROR",
        error: "API keys not configured. Please open the extension popup."
      });
    }
  }
});

chrome.runtime.onInstalled.addListener(async () => {
  console.log("üîÑ [background] Extension installed/updated, injecting content scripts...");
  const manifest = chrome.runtime.getManifest();
  const cs = manifest.content_scripts[0];
  const matches = cs.matches;

  const tabs = await chrome.tabs.query({ url: matches });
  console.log(`üîç [background] Found ${tabs.length} Google Forms tabs to inject`);

  for (let tab of tabs) {
    try {
      await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        files: cs.js,
      });
      console.log(`‚úÖ [background] Injected content.js into tab ${tab.id}`);
    } catch (e) {
      console.warn(`‚ö†Ô∏è [background] Failed to inject into tab ${tab.id}:`, e);
    }
  }
});

chrome.runtime.onInstalled.addListener(() => console.log("üöÄ [background] Extension installed"));
chrome.runtime.onStartup.addListener(() => console.log("üîÑ [background] Extension started"));

chrome.runtime.onStartup.addListener(async () => {
  try {
    const response = await fetch(`${API_BASE_URL}/`);
    if (response.ok) {
      console.log("‚úÖ [background] Backend connectivity verified");
    } else {
      console.warn("‚ö†Ô∏è [background] Backend responded with error:", response.status);
    }
  } catch (error) {
    console.warn("‚ö†Ô∏è [background] Backend connectivity test failed:", error.message);
  }
});
